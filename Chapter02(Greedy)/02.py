#큰 수의 법칙
#- 다양한 수로 이루어진 배열이 있을 때, 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙
#(단, 배열의 특정한 index(번호)에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.)
#- Ex) 순서대로 2, 4, 5, 4, 6으로 이루어진 배열이 있을 때, M이 8이고, K가 3이라고 가정하자. 이 경우 특정한 인덱스의 수가 연속해서 3번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6+6+6+5+6+6+6+5인 46이다.
#- 단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주
#ex) 3, 4, 3, 4, 3일 때는 4+4+4+4+4+4+4+4인 32가 될 수 있다.
#- 배열의 크기N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때, 큰 수의 법칙에 따른 결과를 출력하시오.
#(조건)
#1. 첫째 줄에 N(2≤N≤1000), M(1≤M≤10000), K(1≤K≤10000)의 자연수가 주어지며, 각 자연수는 공백으로 구분한다.
#2. 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1이상 10000이하의 수로 주어진다.
#3. 입력으로 주어지는 K는 항상 M보다 작거나 같다.

N,M,K=map(int,input().split()) #N, M, K를 int형 변수로 공백을 기준으로 입력받는다.

my_array=list(map(int, input().split())) #N개의 수를 공백을 기준으로 입력받고 list로 만들어 my_array에 저장

max=0 #가장 큰수를 넣을 변수
s_max=0 #다음으로 큰수를 넣을 변수

for i in range(N): #가장 큰수와 두번째로 큰수를 찾는 for문이다.
    if my_array[i]>=max:
        s_max=max
        max=my_array[i]

count=0 #같은 인덱스의 숫자를 K번까지 더할 수 있으므로, 그 조건을 위한 변수 (count<K의 조건을 만족할 때까지 같은 인덱스의 수 더한다)
sum=0 #배열에서 숫자를 뽑아 가장 큰수를 만들 때, 결과값을 저장할 변수 (구하고자 하는 값)

for j in range(M): #결과값이 가장 큰수가 나올 수 있도록 반복하는 for문
    if(count==K): #count가 K만큼 되었을 떄, 즉 같은 인덱스의 숫자가 K만큼 연속적으로 더해졌을 때의 예외처리
        sum+=s_max
        count=0 #다음으로 큰수인 s_max를 한번 더하고 count를 0으로 리셋한다.
    else: #K만큼 연속적으로 더해지지 않았다면 계속 결과값에 가장 큰수 max를 더한다.
        sum += max
        count += 1

print(sum)